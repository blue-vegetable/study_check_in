# wry0904

## 功耗基础知识

主要学习一些基础知识，看下对方向是否感兴趣。

### DVFS

DVFS （Dynamic voltage and frequency scaling）即动态电压频率调整，动态技术则是根据芯片所运行的应用程序对计算能力的不同需要，动态调节芯片的运行频率和电压(对于同一芯片，频率越高，需要的电压也越高)，从而达到节能的目的。

降低频率可以降低功率，但是单纯地降低频率并不能节省能量。因为对于一个给定的任务，F*t是一个常量，只有在降低频率的同时降低电压，才能真正地降低能量的消耗。

DVFS系统流程： 1. 采集与系统负载有关的信号，计算当前的系统负载。 2. 根据系统的当前负载，预测系统在下一时间段需要的性能。 3. 将预测的性能转换成需要的频率，从而调整芯片的时钟设置。 4. 根据新的频率计算相应的电压。通知[电源管理](https://baike.baidu.com/item/电源管理/1190367?fromModule=lemma_inlink)模块调整给CPU的电压。另外，在调整频率和电压时，要特别注意调整的顺序。**当频率由高到低调整时，应该先降频率，再降电压；相反，当升高频率时，应该先升电压，再升频率。**

### DPM技术

DPM（dynamic power management）

动态电源管理（Dynamic Power Management，DPM）技术有选择的把闲置的系统模块关闭或者置于低能耗状态，从而有效的利用电能。DPM基于下面的假设：

- 系统各个部分的工作负载不同
- 系统在每个工作时刻的负载不同
- 工作负载可以预测

> https://www.mrbluyee.com/2019/02/03/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97/

### 功耗和电压、频率的关系

公式如下所示，P代表能耗。C可以简单看作一个常数，它由制程和设计等因素决定；V代表电压；而f就是频率了
$$
P = CV^2f
$$

但是这个公式是理想状态下的公式，但是随着f的增加，会导致需要加压才能稳定下来。随意P和频率的关系是非线性的。

当我们不断提高频率f后，过了某个节点，太快的翻转会造成门延迟跟不上，从而影响数字信号的完整性，从而造成错误。这也是为什么超频到某个阶段会不稳定，随机出错的原因。那么怎么办呢？聪明的你也许想到了超频中常用的办法：加压。对了，可以通过提高电压来减小门延迟，让系统重新稳定下来。

> https://zhuanlan.zhihu.com/p/35120669

## 调度基础知识

### CFS调度器（Linux一直在用）

CFS是Completely Fair Scheduler简称，即完全公平调度器。CFS的设计理念是在真实硬件上实现理想的、精确的多任务CPU。CFS调度器和以往的调度器不同之处在于没有时间片的概念，而是分配cpu使用时间的比例。例如：2个相同优先级的进程在一个cpu上运行，那么每个进程都将会分配50%的cpu运行时间。这就是要实现的公平。

**分配给进程的时间 = 总的cpu时间 \* 进程的权重/就绪队列（runqueue）所有进程权重之和**

#### 调度延时

调度延迟就是保证每一个可运行进程都至少运行一次的时间间隔。

#### 虚拟时间

（自欺欺人时间）

### EAS调度器（Arm公司针对异构芯片的扩展）

Linux内核CFS调度器和SMP[负载均衡](https://so.csdn.net/so/search?q=负载均衡&spm=1001.2101.3001.7020)主要是为了性能优先场景而考虑，而采用大小核设计的产品大部分采用电池供电，更应该优先考虑功耗优先。

**EAS设计目标**：在保证满足系统性能的前提下，尽可能的降低功耗；通过合理的选择CPU来执行任务，合理的调整CPU频率。

资料较少，遇到再说。

### 调频器的governor一些策略（Performance、Powersave、Schedutil、Ondmand...）

> https://forum.xda-developers.com/t/cpu-governors-explained.1663809/
>
> https://cloud.tencent.com/developer/article/2003317

曾经使用过的governor ，

- `performance` CPU 一直跑在最高频率
- `powersave `

```
 让 CPU 跑在最低频率
```

- `ondemand ` governor 开启一个 timer，定期去计算各个 CPU 的负载。当 CPU 负载超过 80% 时， 就会把 CPU 频率调到最高，其他情况则会根据当前负载按比例计算频率。
- `conservation `  **governor 开启一个 timer，定期去计算各个 CPU 的负载。当CPU 负载超过 80% 时，默认会以 5% 的步伐递增；当 CPU 负载少于 20% 的时候，默认会以 5% 的步伐递减。**
- **` Interactive governor`** 

​           它是在 Android 中引入的。它在每一个 CPU 上都注册了一个 idle notifier。当 CPU 退出 idle 状态时，interactive 就会缩减采样频率，从而可以快速响应负载变化。其他情况下，会根据当前 CPU 负载调整频率，这一点和 ondemand 类似。

## 论文

### A Survey on Recent OS-Level Energy Management Techniques for Mobile Processing Units

主要是一个关于低功耗的综述，介绍了目前的降功耗思路包括， 硬件方面的和软件方面的

硬件方面主要是，添加硬件以适应处理单元的功耗状态，通常在移动设备上用，提供能耗管理原语。

软件方面主要是基于操作系统的，基于操作系统的自己的算法和策略调整功耗的状态，因为操作系统知道用户在干嘛，所以能够做到更少的影响用户体验并减低功耗。

我主要需要了解的是调节处理单元的功耗来降低整体功耗，但是不想看了。摆了，明天再去看。

