### 8-28

Leetcode 热题100 简单题：

21 合并两个有序列表  没啥说的

94 二叉树的中序遍历 递归，顺便复习了下三种遍历

104 二叉树的最大深度 递归

101 对称二叉树 稍卡了下，还是递归判断左右子树

141 环形链表 做过的题，无脑双指针

160 相交链表有点意思，一开始没看懂题目，用a +b ，找交点 O（1)空间解决确实妙

206 反转链表 无脑递归，不过就几行代码还有个bug卡了10分钟，要找个好点的调试工具了

283 移动零  双指针

338 比特位计数 按题目来做就行

448 找到所有数组中消失的数字 题目很简单，但是用O（1）空间复杂度有点想不到

461 汉明距离  无脑模拟

617 合并二叉树	递归两棵树即可

中等题：

完了简单题做完了，中等题做不来了

3 无重复字符的最长子串 滑动窗口

31 下一个排列   这题把题目分析清楚就行，没有算法难度，有bug整了半小时，给我整破防了



#### mysql 

##### 关系型和非关系型数据库的区别

关系型数据库的优点

- 容易理解，因为它采用了关系模型来组织数据。
- 可以保持数据的一致性。
- 数据更新的开销比较小。
- 支持复杂查询（带 where 子句的查询）

关系型数据库（NOSQL）的优点

- 无需经过 SQL 层的解析，读写效率高。
- 基于键值对，读写性能很高，易于扩展
- 可以支持多种类型数据的存储，如图片，文档等等。
- 扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。

##### 索引与存储

https://blog.csdn.net/qq_24313635/article/details/102924190

***存储引擎  MySQL中的数据用各种不同的技术存储在文件***

**InnoDB是事务型数据库的首选引擎，**支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎，InnoDB主要特性有：

```
1、InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合。

2、InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的。

3、InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。

4、InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键

5、InnoDB被用在众多需要高性能的大型数据库站点上。

6、InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件
```

**MyISAM存储引擎**

MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM主要特性有：

```
1、大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持。

2、当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成。

3、每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16。

4、最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上。

5、BLOB和TEXT列可以被索引。

6、NULL被允许在索引的列中，这个值占每个键的0~1个字节。

7、所有数字键值以高字节优先被存储以允许一个更高的索引压缩。

8、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快。

9、可以把数据文件和索引文件放在不同目录。

10、每个字符列可以有不同的字符集。

11、有VARCHAR的表可以固定或动态记录长度。

12、VARCHAR和CHAR列可以多达64KB。

13、使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）
```

**MEMORY存储引擎**

MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。MEMORY主要特性有：

```
1、MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度

2、MEMORY存储引擎执行HASH和BTREE缩影

3、可以在一个MEMORY表中有非唯一键值

4、MEMORY表使用一个固定的记录长度格式

5、MEMORY不支持BLOB或TEXT列

6、MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引

7、MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）

8、MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享

9、当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）
```

*如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择*

*如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率*

*如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果*



***\索引的理解：在数据之外，数据库系统还维护着满足特定查找算法的数据结构，包括B+树或者Hash表。由于存储引擎表示的是数据在磁盘上面的不同的组织形式，所以索引底层采用哪种数据结构是跟数据库的存储引擎相关的。如果是MyIsam或者是InnoDB存储引擎，那么对应的底层的数据结构为B+树，如果是Memory存储引擎，那么对应的底层的数据结构为Hash表。\***

##### B+树和B树有什么不同:

```
1. B+树非叶子节点不存储数据的，仅存储键值(索引地址)，而B树节点中不仅存储键值，也会存储数据。B+树之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数会再次减少，数据查询的效率也会更快 。
2. B+树索引的所有数据均存储在叶子节点，且数据是按照顺序排列的。B+树使得范围查找，排序查找，分组查找以及去重查找变得简单高效
3. B+树各个页之间是通过双向链表连接，叶子节点中的数据是通过单向链表连接的。我们通过双向链表和单向链表连接的方式可以找到表中所有的数据。
```



##### 聚簇索引与非聚簇索引

```
InnoDB的数据文件本身就是索引文件，表数据文件本身就是按 B+ 树组织的一个索引结构，其叶子节点的键值就是表的主键，这种数据存储方式也被称为聚簇索引。由此可见，聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。
```

![aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzgvMTZhOTUzMjcyZWI2YTI1Zg](C:\Users\33243\Desktop\study_check_in\assets\aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzgvMTZhOTUzMjcyZWI2YTI1Zg.png)

```
MyISAM存储引擎索引文件和数据文件是分开的，MyISAM引擎按照数据插入顺序，将数据文件存储在磁盘上。MyISAM引擎使用 B+ 树作为索引结构，叶节点存放的是数据记录的行指针。

辅助索引也叫非聚簇索引，二级索引等。同 `MyISAM` 引擎的辅助索引实现不同，`InnoDB` 的辅助索引，其叶子节点存储的不是行指针而是主键值，得到主键值再要查询具体行数据的话，要去聚簇索引中再查找一次，也叫回表。这样的策略优势是减少了当出现行移动或者数据页分裂时二级索引的维护工作。
```

![aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzgvMTZhOTUzMjc4OWM4YjI5ZQ](C:\Users\33243\Desktop\study_check_in\assets\aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzgvMTZhOTUzMjc4OWM4YjI5ZQ.png)

##### MySQL不推荐使用uuid作为主键

```
因为uuid相对顺序的自增id来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以innodb无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。

这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：

①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO

②因为写入是乱序的，innodb不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上

③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片
```



#### 事务

1、事务的ACID特性

        原子性(Atomicity)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。
        
        一致性(Consistency)：一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态。
    
        隔离性(Isolation)：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。
    
        持久性(Durability)：一个事务一旦被提交，此事务对数据库中数据的改变就是永久性的。

2、事务的四种特性是基于什么机制实现的

        事务的隔离性是由锁机制实现的
        
        事务的原子性、一致性由undo log实现
    
        事务的持久性由redo log实现                                               
        
        https://blog.csdn.net/weixin_51261234/article/details/124908426
        (undo log 逻辑日志和 redo log 物理日志详解)
        https://www.cnblogs.com/better-farther-world2099/articles/14768929.html
        (Buffer Pool详解)                                                                     

3、InnoDB支持的四种事务隔离级别

        读未提交：可避免脏写，无法避免脏读、不可重复读、幻读
         
        读已提交（利用MVCC）：可避免脏写、脏读
    
        可重复读（利用MVCC）：可避免脏写、脏读、不可重复读、幻读
    
        串行化（利用加互斥读写锁）：可避免脏写、脏读、不可重复读、幻读                               

4、数据并发产生的问题

        脏写：A事务修改了未提交的B事务修改过的数据
        
        脏读：A事务读取到了未提交的B事务修改过的数据
    
        不可重复读：A事务读取数据，B事务更新数据，A事务再次读的时候读取到了B事务更新过的数据
    
        幻读：A事务从表中读取了一些行数据，B事务在该表中插入了一些新的行，A事务再次读取同一个表，发现多出几行。

5、 MySQL中有哪几种锁

        按照数据的操作类型划分：共享锁、排他(独占)锁
        
        按照数据操作粒度划分：表级锁、行级锁、页级锁
    
        按照对待锁的态度划分：乐观锁、悲观锁

